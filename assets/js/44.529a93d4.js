(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{833:function(t,r,v){"use strict";v.r(r);var a=v(112),_=Object(a.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",[t._v("V8 垃圾回收机制")]),t._v(" "),v("p",[t._v("垃圾回收分为两个阶段：")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("标记阶段")]),t._v("：判断一个对象是否可以回收，一般使用"),v("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//github.com/Lord-X/awesome-it-blog/blob/master/java/JVM-GC%25E5%259E%2583%25E5%259C%25BE%25E5%259B%259E%25E6%2594%25B6%25E7%25AE%2597%25E6%25B3%2595-%25E5%25BC%2595%25E7%2594%25A8%25E8%25AE%25A1%25E6%2595%25B0%25E6%25B3%2595.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("引用计数法"),v("OutboundLink")],1),t._v("和"),v("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//github.com/Lord-X/awesome-it-blog/blob/master/java/JVM-GC%25E5%259E%2583%25E5%259C%25BE%25E5%259B%259E%25E6%2594%25B6%25E7%25AE%2597%25E6%25B3%2595-%25E5%2588%25A4%25E5%25AE%259A%25E4%25B8%2580%25E4%25B8%25AA%25E5%25AF%25B9%25E8%25B1%25A1%25E6%2598%25AF%25E5%2590%25A6%25E6%2598%25AF%25E5%258F%25AF%25E5%259B%259E%25E6%2594%25B6%25E7%259A%2584%25E5%25AF%25B9%25E8%25B1%25A1.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("可达性分析法"),v("OutboundLink")],1),t._v("；")]),t._v(" "),v("li",[v("strong",[t._v("回收阶段")]),t._v("：销毁可以被回收的对象，常见算法有："),v("strong",[t._v("标记清除算法")]),t._v("、"),v("strong",[t._v("复制算法")]),t._v("、"),v("strong",[t._v("标记压缩算法")]),t._v("、"),v("strong",[t._v("分代算法")]),t._v("。")])]),t._v(" "),v("h2",{attrs:{id:"常用-gc-算法"}},[t._v("常用 GC 算法 "),v("a",{staticClass:"header-anchor",attrs:{href:"#常用-gc-算法"}},[t._v("#")])]),t._v(" "),v("h3",{attrs:{id:"标记清除算法"}},[t._v("标记清除算法 "),v("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[t._v("#")])]),t._v(" "),v("p",[t._v("标记清除法是现在GC算法的基础。标记清除算法的执行过程分为两个阶段：标记阶段、清除阶段。")]),t._v(" "),v("ul",[v("li",[t._v("标记阶段会通过可达性分析将不可达的对象标记出来。")]),t._v(" "),v("li",[t._v("清除阶段会将标记阶段标记的垃圾对象清除。\n标记清除法的缺陷是"),v("strong",[t._v("回收后会产生大量不连续的内存空间，即内存碎片")]),t._v("。")])]),t._v(" "),v("h3",{attrs:{id:"复制算法"}},[t._v("复制算法 "),v("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[t._v("#")])]),t._v(" "),v("p",[t._v("复制算法会将内存空间分为两块，每次只使用其中一块内存。\n复制算法同样使用可达性分析法标记除垃圾对象，当GC执行时，会将非垃圾对象复制到另一块内存空间中，并且保证内存上的连续性，然后直接清空之前使用的内存空间。然后如此往复。\n该算法在存活对象少，垃圾对象多的情况下，非常高效。其好处是不会产生内存碎片，但"),v("strong",[t._v("坏处也是显而易见的，就是直接损失了一半的可用内存")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"标记压缩算法"}},[t._v("标记压缩算法 "),v("a",{staticClass:"header-anchor",attrs:{href:"#标记压缩算法"}},[t._v("#")])]),t._v(" "),v("p",[t._v("标记压缩算法可以解决标记清除算法的内存碎片问题。\n其算法可以看作三步：")]),t._v(" "),v("ol",[v("li",[t._v("标记垃圾对象")]),t._v(" "),v("li",[t._v("清除垃圾对象")]),t._v(" "),v("li",[t._v("内存碎片整理\n"),v("strong",[t._v("标记压缩算法的碎片整理会造成较大的消耗")])])]),t._v(" "),v("h3",{attrs:{id:"分代算法"}},[t._v("分代算法 "),v("a",{staticClass:"header-anchor",attrs:{href:"#分代算法"}},[t._v("#")])]),t._v(" "),v("p",[t._v("首先，标记清除算法、复制算法、标记压缩算法都有各自的缺点，如果单独用其中某一算法来做GC，会有很大的问题。例如，标记清除算法会产生大量的内存碎片，复制算法会损失一半的内存，标记压缩算法的碎片整理会造成较大的消耗。\n其次，复制算法和标记压缩算法都有各自适合的使用场景。复制算法适用于每次回收时，存活对象少的场景，这样就会减少复制量。标记压缩算法适用于回收时，存活对象多的场景，这样就会减少内存碎片的产生，碎片整理的代价就会小很多。\n分代算法将内存区域分为两部分：新生代和老年代。\n根据新生代和老年代中对象的不同特点，使用不同的GC算法。")]),t._v(" "),v("ul",[v("li",[t._v("新生代对象的特点是：创建出来没多久就可以被回收（例如虚拟机栈中创建的对象，方法出栈就会销毁）。也就是说，每次回收时，大部分是垃圾对象，所以新生代适用于复制算法。")]),t._v(" "),v("li",[t._v("老生代的特点是：经过多次GC，依然存活。也就是说，每次GC时，大部分是存活对象，所以老年代适用于标记压缩算法。")])]),t._v(" "),v("h2",{attrs:{id:"v8-垃圾回收"}},[t._v("V8 垃圾回收 "),v("a",{staticClass:"header-anchor",attrs:{href:"#v8-垃圾回收"}},[t._v("#")])]),t._v(" "),v("p",[t._v("V8 的垃圾回收策略主要基于分代式垃圾回收机制。\nV8对内存大小做了限制，64位操作系统最大为1.4GB，32为系统最大为0.7GB。这么做的原因主要有以下两点：")]),t._v(" "),v("ol",[v("li",[t._v("V8主要是服务于浏览器的，浏览器不太可能遇到需要大内存的场景。")]),t._v(" "),v("li",[t._v("64位系统之所以设计成1.4GB的上限是有考量的，因为如果内存超过1.4GB的时候，V8做一次最小的垃圾回收需要50ms以上，做非增量垃圾回收需要1秒以上，在回收过程中会阻塞JS执行，这个时候你会觉得浏览器卡死了。所以设置1.4GB最大内存是一个平衡的选择。\n因为垃圾回收会阻塞JS代码，所以怎么高效的进行垃圾回收就显得非常重要了。"),v("strong",[t._v("V8 的垃圾回收策略主要基于分代式垃圾回收机制")]),t._v("。")])]),t._v(" "),v("h3",{attrs:{id:"v8如何回收新生代"}},[t._v("V8如何回收新生代 "),v("a",{staticClass:"header-anchor",attrs:{href:"#v8如何回收新生代"}},[t._v("#")])]),t._v(" "),v("p",[t._v("新生代因为存放的是一些存活时间短的对象，所以为了效率考虑，其回收频率也会比较高。其回收策略采用的是标记 + 复制。")]),t._v(" "),v("p",[v("img",{attrs:{src:"v8-from-to.png",alt:"v8-from-to"}})]),t._v(" "),v("p",[t._v("如上图所示，新生代内存等分为两个区域，From为活动区域，To为复制区域。\n当我们分配对象时，先是在From空间中进行分配，当要触发垃圾回收的时候，From就会先进行标记，标记完成后，将可达对象（活动对象）复制到To区域，然后把From区域整理进行清除，清除完成后From和To区域交换一下。")]),t._v(" "),v("h3",{attrs:{id:"晋升"}},[t._v("晋升 "),v("a",{staticClass:"header-anchor",attrs:{href:"#晋升"}},[t._v("#")])]),t._v(" "),v("p",[t._v("我们前面说过新生代内存上限是32MB，这点内存很容易就能达到，所以如果一些对象经常存在新生代里的话，很容易新生代内存就占满了，所以V8存在一种晋升机制，但满足下面条件的时候，新生代对象就会移动到老生代区域，简称晋升，这个过程发生在From区域将活动对象拷贝至To区域过程中。")]),t._v(" "),v("ol",[v("li",[t._v("一轮垃圾回收（GC）后还存活的新生代对象需要晋升。也就是说上一轮垃圾回收后，这一轮垃圾回收发现你还是活动对象，就需要把你晋升到老生代区域。")]),t._v(" "),v("li",[t._v("To空间的使用率超过25%，如果超过25%，后续对象直接晋升。这也是个衡量结果，超过25%，后续新进来的对象就会有些不够用了。")])]),t._v(" "),v("h3",{attrs:{id:"v8如何回收老生代"}},[t._v("V8如何回收老生代 "),v("a",{staticClass:"header-anchor",attrs:{href:"#v8如何回收老生代"}},[t._v("#")])]),t._v(" "),v("p",[t._v("老生代存一些持续时间久的对象，比如全局变量，闭包等。它可分配内存大，而且回收频率不像老生代那么频繁。所以它的垃圾回收机制也和不太一样。\n老生代主要是用标记清除策略进行垃圾回收，但是前面说过，标记清除会产生碎片化内存，当新生代对象要晋升到老生代，而老生代没有空间可存的时候，老生代就会进行一次标记整理进行空间优化，优化后在进行晋升操作。")]),t._v(" "),v("h3",{attrs:{id:"增量标记"}},[t._v("增量标记 "),v("a",{staticClass:"header-anchor",attrs:{href:"#增量标记"}},[t._v("#")])]),t._v(" "),v("p",[t._v("垃圾回收（分标记和回收两个阶段）会阻塞JS执行，全堆垃圾回收带来的停顿时间会较长。\nV8 从标记阶段入手，将原本需要一口气停顿完成的动作改成增量标记，即程序执行和垃圾回收穿插着来，这样用户的感知就不明显了。图示如下：")]),t._v(" "),v("p",[v("img",{attrs:{src:"v8-2.png",alt:"v8-2"}})]),t._v(" "),v("p",[t._v("V8 在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的 1/6 左右。\nV8 后续还引入了"),v("strong",[t._v("延迟清理（lazy sweeping）"),v("strong",[t._v("与")]),t._v("增量式整理（incremental compaction）")]),t._v("，让清理和整理动作也变成增量式的。同时还计划引入"),v("strong",[t._v("并行标记")]),t._v("和"),v("strong",[t._v("并行清理")]),t._v("，进一步利用多核性能降低每次停顿的时间。")]),t._v(" "),v("h2",{attrs:{id:"参考资料"}},[t._v("参考资料 "),v("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")])]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://juejin.cn/post/6844903934641831944",target:"_blank",rel:"noopener noreferrer"}},[t._v("谈谈V8引擎GC原理"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://juejin.cn/post/6891067298711355399#heading-5",target:"_blank",rel:"noopener noreferrer"}},[t._v("V8内存管理"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/81676751",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java GC回收算法-标记清除法、复制算法、标记压缩法、分代算法"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=_.exports}}]);