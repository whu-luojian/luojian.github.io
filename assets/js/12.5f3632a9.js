(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{831:function(e,v,_){"use strict";_.r(v);var c=_(112),o=Object(c.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",[e._v("漏网之鱼")]),e._v(" "),_("ul",[_("li",[e._v("以 "),_("code",[e._v("Webpack")]),e._v(" 为首的工具中，历史上编译构建速度较慢，即便监听文件启动增量构建，也无法解决初始时构建时间过长的问题。而 "),_("code",[e._v("Parcel")]),e._v(" 主要内置了多核并行构建，利用多线程实现编译能力，在初始构建阶段就能获得较理想的构建速度。同时 "),_("code",[e._v("Parcel")]),e._v(" 还内置了文件系统缓存，可以保存每个文件的编译结果。这一方面 "),_("code",[e._v("Webpack")]),e._v(" 新版本（"),_("code",[e._v("v5")]),e._v("）也都有相应跟进。")]),e._v(" "),_("li",[_("code",[e._v("Webpack")]),e._v(" 中的 "),_("code",[e._v("hash/chunkhash/contenthash")]),e._v("：\n"),_("ul",[_("li",[_("code",[e._v("hash:")]),e._v(" 同一次构建过程中生成的 "),_("code",[e._v("hash")]),e._v(" 是一样的，每一次构建后生成的哈希值都不一样，即使文件内容压根没有改变；")]),e._v(" "),_("li",[_("code",[e._v("chunkhash:")]),e._v(" 根据入口文件进行依赖解析，同一入口下的文件 "),_("code",[e._v("hash")]),e._v(" 一样；")]),e._v(" "),_("li",[_("code",[e._v("contenthash:")]),e._v("  根据文件内容，生成 "),_("code",[e._v("hash")]),e._v(" 值。")])])])])])}),[],!1,null,null,null);v.default=o.exports}}]);