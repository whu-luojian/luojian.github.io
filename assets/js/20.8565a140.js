(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{835:function(t,s,r){"use strict";r.r(s);var n=r(115),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",[t._v("前端虚拟列表的三种实现方案")]),t._v(" "),r("h2",{attrs:{id:"长列表"}},[t._v("长列表 "),r("a",{staticClass:"header-anchor",attrs:{href:"#长列表"}},[t._v("#")])]),t._v(" "),r("p",[t._v("前端业务开发中会遇到一些数据长度很大，同时不能采用分页方式来加载的列表，这种列表一般被称为长列表。")]),t._v(" "),r("p",[t._v("DOM元素的创建和渲染（主要是渲染）需要的时间成本很高。在大数据的情况下，完整渲染长列表所需的内存和耗时也是极大的，轻则页面卡顿，重则页面崩溃，所以完整渲染的长列表很难达到业务上的要求，因此通常采用非完整渲染长列表，非完整渲染的长列表一般有两种方式：")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("懒渲染")]),t._v("：最常见的就是"),r("strong",[t._v("无限滚动（触底加载）")]),t._v("，就是在滚动到容器底部的时候，再去加载剩余的数据。这是前后端共同优化的方式，初次请求并渲染第一页的数据，滚动触底再请求并渲染第二页数据。")]),t._v(" "),r("li",[r("strong",[t._v("可视区域渲染")]),t._v("：可是区域渲染指的是只渲染可视区域的列表项，非可见区域的不渲染，在滚动条滚动时动态更新列表项，这种列表一般叫做 Virtual List (虚拟列表)。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);