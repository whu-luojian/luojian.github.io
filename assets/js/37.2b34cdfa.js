(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{819:function(_,v,e){"use strict";e.r(v);var o=e(112),c=Object(o.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",[_._v("Yarn 安装机制")]),_._v(" "),e("p",[e("code",[_._v("Yarn")]),_._v(" 是一个由 "),e("code",[_._v("Facebook")]),_._v(" 、"),e("code",[_._v("Google")]),_._v(" 、"),e("code",[_._v("Exponent")]),_._v(" 和 "),e("code",[_._v("Tilde")]),_._v(" 构建的新的 "),e("code",[_._v("JavaScript")]),_._v(" 包管理器。它的出现是为了解决历史上 "),e("code",[_._v("npm")]),_._v(" 的某些不足（比如 "),e("code",[_._v("npm")]),_._v(" 对于依赖的完整性和一致性保障，以及 "),e("code",[_._v("npm")]),_._v(" 安装速度过慢的问题等）。")]),_._v(" "),e("h2",{attrs:{id:"安装理念"}},[_._v("安装理念 "),e("a",{staticClass:"header-anchor",attrs:{href:"#安装理念"}},[_._v("#")])]),_._v(" "),e("ul",[e("li",[e("strong",[_._v("确定性")]),_._v("：通过 "),e("code",[_._v("yarn.lock")]),_._v(" 等机制，保证相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装。")]),_._v(" "),e("li",[e("strong",[_._v("扁平化安装")]),_._v("：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（"),e("code",[_._v("npm")]),_._v(" 目前也有相同的优化）。")]),_._v(" "),e("li",[e("strong",[_._v("网络性能更好")]),_._v("："),e("code",[_._v("Yarn")]),_._v(" 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制。")]),_._v(" "),e("li",[e("strong",[_._v("缓存机制")]),_._v("：采用缓存机制，实现了离线模式（"),e("code",[_._v("npm")]),_._v(" 目前也有类似实现）。")])]),_._v(" "),e("h2",{attrs:{id:"yarn-lock"}},[e("code",[_._v("yarn.lock")]),_._v(" "),e("a",{staticClass:"header-anchor",attrs:{href:"#yarn-lock"}},[_._v("#")])]),_._v(" "),e("ol",[e("li",[e("code",[_._v("yarn.lock")]),_._v(" 结构整体和 "),e("code",[_._v("package-lock.json")]),_._v(" 结构类似。"),e("code",[_._v("yarn.lock")]),_._v(" 并没有使用 "),e("code",[_._v("json")]),_._v(" 格式，而是采用了一种可读性较高的自定义标记格式。")]),_._v(" "),e("li",[_._v("**"),e("code",[_._v("yarn.lock")]),_._v(" 中子依赖的版本号不是固定版本 。**这说明 "),e("code",[_._v("yarn.lock")]),_._v(" 和 "),e("code",[_._v("package.json")]),_._v(" 配合才能确定 "),e("code",[_._v("node_modules")]),_._v(" 目录结构。")])]),_._v(" "),e("h2",{attrs:{id:"安装机制"}},[_._v("安装机制 "),e("a",{staticClass:"header-anchor",attrs:{href:"#安装机制"}},[_._v("#")])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/8A/17/CgqCHl_ZflCANVu8AAJJZZYzwhs026.png",alt:"img"}})]),_._v(" "),e("ol",[e("li",[e("p",[_._v("检测包（"),e("code",[_._v("checking")]),_._v("）：")]),_._v(" "),e("ul",[e("li",[_._v("检测项目中是否存在 "),e("code",[_._v("npm")]),_._v(" 相关文件，比如 "),e("code",[_._v("package-lock.json")]),_._v(" 等。如果有，则提示用户注意：这些文件的存在可能导致冲突。")]),_._v(" "),e("li",[_._v("这一步骤中，也会检查系统 "),e("code",[_._v("OS")]),_._v(" 、"),e("code",[_._v("CPU")]),_._v(" 等信息。")])])]),_._v(" "),e("li",[e("p",[_._v("解析包（"),e("code",[_._v("resolving packages")]),_._v("）：")]),_._v(" "),e("ul",[e("li",[_._v("获取首层依赖："),e("code",[_._v("dependencies")]),_._v(" 、"),e("code",[_._v("devDependcies")]),_._v(" 、"),e("code",[_._v("optionalDependencies")]),_._v("；")]),_._v(" "),e("li",[_._v("遍历首层依赖以及递归查找每个依赖下嵌套依赖的版本信息，将解析过和正在解析的包用一个 "),e("code",[_._v("Set")]),_._v(" 数据结构存储，保证统一版本范围内的包不会被重复解析：对于没有解析过的包，先尝试从 "),e("code",[_._v("yarn.lock")]),_._v(" 中获取版本信息，如若找不到则向 "),e("code",[_._v("Registry")]),_._v(" 发起请求获取满足版本范围内的已知最高的包信息；")]),_._v(" "),e("li",[_._v("最终确定所有依赖的具体版本信息以及下载地址。")])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/84/9F/CgqCHl_TbimACnDOAAFMC14gP8I289.png",alt:"Drawing 2.png"}})])]),_._v(" "),e("li",[e("p",[_._v("获取包（"),e("code",[_._v("fetching packages")]),_._v("）:")]),_._v(" "),e("ul",[e("li",[_._v("检查缓存中是否当前依赖包，未命中缓存则下载包到缓存目录。")])]),_._v(" "),e("p",[e("img",{attrs:{src:"https://s0.lgstatic.com/i/image/M00/84/94/Ciqc1F_TbjKAThkOAAEsp0sOHUc622.png",alt:"Drawing 3.png"}})])]),_._v(" "),e("li",[e("p",[_._v("链接包（"),e("code",[_._v("linking packages")]),_._v("）：")]),_._v(" "),e("ul",[e("li",[_._v("解析 "),e("code",[_._v("peerDependencies")]),_._v(" ，如果找不到符合 "),e("code",[_._v("peerDependencies")]),_._v(" 的包，则进行 "),e("code",[_._v("warning")]),_._v(" 提示；")]),_._v(" "),e("li",[_._v("遵循"),e("strong",[_._v("扁平化原则")]),_._v("，将项目中的依赖复制到项目 "),e("code",[_._v("node_modules")]),_._v(" 下。")])])]),_._v(" "),e("li",[e("p",[_._v("构建包 ("),e("code",[_._v("building packages")]),_._v(")：")]),_._v(" "),e("ul",[e("li",[_._v("如果依赖包中存在二进制文件需要进行编译，则执行编译构建。")])])])]),_._v(" "),e("h2",{attrs:{id:"扁平化安装"}},[_._v("扁平化安装 "),e("a",{staticClass:"header-anchor",attrs:{href:"#扁平化安装"}},[_._v("#")])]),_._v(" "),e("p",[_._v("早期 "),e("code",[_._v("npm")]),_._v("（"),e("code",[_._v("npm v2")]),_._v("）的设计非常简单，在安装依赖时将依赖放到项目的 "),e("code",[_._v("node_modules")]),_._v("文件中；同时如果某个直接依赖 A 还依赖其他模块 B，作为间接依赖，模块 B 将会被下载到 A 的 "),e("code",[_._v("node_modules")]),_._v(" 文件夹中，依此递归执行，最终形成了一颗巨大的依赖模块树，表现为：")]),_._v(" "),e("ul",[e("li",[_._v("项目依赖树层级非常深，不利于调试和排查问题；")]),_._v(" "),e("li",[_._v("依赖树的不同分支里，可能存在同样版本的相同依赖；")])]),_._v(" "),e("p",[_._v("带来的问题是：")]),_._v(" "),e("ol",[e("li",[_._v("依赖重复安装，浪费较大空间资源，也使得安装速度过慢；")]),_._v(" "),e("li",[_._v("目录层级太深，导致文件路径太长，导致 "),e("code",[_._v("windows")]),_._v(" 系统下删除 "),e("code",[_._v("node_modules")]),_._v(" 文件夹失败。")])]),_._v(" "),e("p",[e("code",[_._v("npm v3")]),_._v(" 之后，"),e("code",[_._v("node_modules")]),_._v(" 的结构改成了扁平结构：")]),_._v(" "),e("ul",[e("li",[_._v("不管是直接依赖还是子依赖的依赖，优先放置在 "),e("code",[_._v("node_modules")]),_._v(" 根目录；")]),_._v(" "),e("li",[_._v("遇到相同依赖，判断已放置在依赖树中的依赖是否符合新依赖的版本范围，如果符合则跳过；不符合则在当前依赖的 "),e("code",[_._v("node_modules")]),_._v(" 下放置该依赖。")])])])}),[],!1,null,null,null);v.default=c.exports}}]);